# Тема 2. Файлы в UNIX

## 1_copy_file

Программа принимает на вход 2 аргумента - имя копируемого файла и путь, по которому нужно создать копию.
Если аргументов меньше 2, возвращается ошибка.

Копируемый файл открывается на чтение (флаг `O_RDONLY`).

Файл, в который копируются данные, открывается на запись с флагами `O_WRONLY | O_CREAT | O_TRUNC`. 
Флаг `O_CREAT` заставляет ОС создать файл, если он файл существует.
Флаг `O_TRUNC` заставляет ОС стереть старые данные файла, если файл существует.

Файл создается с разрешениями на чтение и запись для владельца
файла (комбинация `S_IRUSR|S_IWUSR`).

Копирование производится блоками по 1КБ. 
Копирование заканчивается, когда вызов `read()` возвращает 0 - т.е., достигнут конец копируемого файла.

---
## 2_dup

### Общие сведения
Программа демонстрирует примеры дублирования файловых дескрипторов.

Каждый открытый файл имеет соотвествующую ему запись в системной таблице открытых файлов.
Данные записи создаются только вызовом `open()`.

Дублированные дескрипторы ссылаются на одну и ту же запись, 
а значит разделяют режим доступа к файлу и позицию чтения-записи.

Дескрипторам 0, 1 и 2 соответствуют потокам ввода, вывода и ошибок. 
Библиотечные функции ввода-вывода неявно используют эти дескрипторы.

### Описание программы

Код в **строках 9-17** демонстрирует применение вызовов `dup()` и `dup2()`, дублирующих дескрипторы.

Вначале программа с помощью вызова `dup()` дублирует дескриптор потока вывода (дескриптор 1), 
после чего выводит сообщение в поток вывода с помощью `printf()`.

Программа закрывает дескриптор потока ввода-вывода. Дескриптор-копия остается открыт.

Затем программа выводит через дескриптор-копию сообщение (вызов `write()`, строка 14), которе успешно отображается.

После этого программа пытается с помощью библиотечной функции вывести еще одно сообщение,
однако т.к. дескриптор 1 закрыт, сообщение не выводится.

Наконец программа восстанавливает дескриптор 1 с помощью вызова `dup2()`, после чего 
библиотечные функции вывода вновь начинают работать.


Код в строках **21-34** демонстрирует наличие общей позиции чтения-записи у дескрипторов, 
ссылающихся на одну и ту же запись в таблице открытых файлов.

Дескриптор `fd2` является копией дескриптора `fd1`.
Если через любой из этих дескрипторов произвести запись, 
то позиция чтения-записи для обоих дескрипторов изменится синхронно, 
т.к. оба дескриптора ссылаются на одну запись в таблице открытых файлов.

Код в строках **37-47** демонстрирует независимость позиции чтения записи для дескрипторов, 
соответствующих разным записям в таблице открытых файлов, даже если открыт один и тот же файл.

---
## 3_fopen

Программа демонстрирует потерю содержимого буферов ввода-вывода
из пространства пользователя при аварийном завершении программы.

Программа принимает на вход 2 опциональных аргумента - тип используемых операций и имя тестового файла.

В качестве первого аргумента могут быть переданы строки:
- `с` (будут использованы функции ввода-вывода из стандартной библиотеки языка С);
- `c++` (будут использованы объекты-потоки из стандартной библиотеки языка С++);
- любая другая (будут использованы системные вызовы).

Общий алгоритм действий программы:

1. Программа открывает тестовый файл на запись и записывает в него строчку.
1. Программа вызывает функцию `abort()`, которая приводит к аварийному завершению программы.

Записанная строчка гарантированно должна появиться в файле при использовании системных вызовов.

В остальных случаях строчка скорее всего не появится,
т.к. при аварийном завершении работы буферы пространства пользователя не успеют сброситься на диск.

---
## 4_lseek_and_stat

Пример демонстрирует работу с позицией чтения записи с помощью вызова  `lseek()`.

Программа сначала создает пустой файл и записывает в него 4 байта (строки 20-22).

Затем программа переносит позицию чтения-записи в начало файла и считывает записанные данные (строки 24-29).

Затем программа переносит позицию чтения-записи в начало файла, перезаписывает данные (строки 31-35) и вновь считывает их (строки 37-41).

Затем программа считывает свойства файла вызовом `fstat()`
и выводит размер файлам в байтах (поле `st_size`) и в дисковых блоках (поле `st_blksize`) (строки 43-47).

Далее программа пытается создать дырку в файле (строки 49-57) 
и проверяет, что чтение в пределах дырки возвращает набор нулей (строки 59-71).

Затем программа вновь считывает свойства файла вызовом `fstat()`и выводит размер файлам в байтах и в дисковых блоках. 
Если файловая система, на которой расположен файл, поддерживает дырки в файлах,
то размер файла в байтах изменится значительно, а в блоках - изменится незначительно или не изменится вовсе (строки 43-47).

---
## 5_flock

Программа демонстрирует применение блокировки файла для предотвращения параллельного запуска.

Программа создает/открывает файл по заданному пути и пытается наложить блокировку вызовом `flock()` (строка 14).

Если блокировка наложена успешно, то программа записывает свой идентификатор процесса в файл и приостанавливается.
Для того чтобы завершить программу, достаточно ввести что-нибудь и нажать Enter.

Если блокировку наложить не получается, 
то программа считывает из файла идентификатор процесса, который держит блокировку, и выводит его в сообщении об ошибке.

Заметьте, что если в вызове `flock()` не указать флаг `LOCK_NB` (строка 14),
то программа просто приостановится до получения блокировки.

---
## 6_ioctl

Программа демонстрирует использование вызова `ioctl()` для взаимодейтвия с часами реального времени.

Данные часы есть в каждой системе. В Linux данные часы представлены в виде файла `/dev/rtc`.

Поскольку программа работает с устройством напрямую, ее требуется запускать с правами суперпользователя

    sudo ./6_ioctl

Перед выполнением `ioctl()` программа должна получить файловый дескриптор, связанный с файлом устройства,
с помощью вызова `open()` (строка 23).

Первый вызов `ioctl()` (строка 28) используется для получения текущего времени системы (время указывается по Гринвичу). 
Вызов заполняет структуру `rtc_time`, адрес которой передается в 3 аргументе.

Затем `ioctl()` используется для установления т.н. "будильника" на 15 секунд вперед.

Для этого к текущему времени прибавляется 15 секунд (с учетом переносов секунды-минуты-часы).

После этого выполняется вызов `ioctl()` с параметром `RTC_ALM_SET`, который выставляет время "будильника" (строка 43). 

Затем выполняется вызов `ioctl()` с парамером `RTC_AIE_ON`, который активирует "будильник" (строка 44).

После этого программа выполняет вызов `read()` из файла устройства, 
который приостанавливает программу до тех пор, пока не прозвенит "будильник" (строка 47).

После этого программа вновь получает текущее время и выводит его.

---
## 7_inotify

Программа демонстрирует применение вызовов inotify для слежения за каталогом.

Программа принимает 1 обязательный аргумент - имя каталога.

Программа не завершается автоматически. 
Для завершения программы можно закрыть консоль или нажать комбинацию **Ctrl+C** в консоли.

Программа инициализирует очередь событий вызовом `inotify_init()` (строка 70).

Затем программа активирует отслеживание событий по заданному каталогу с помощью вызова `inotify_add_watch()`.

После этого программа входит в цикл считывания событий.

Вызов `read()`  всегда считывает не менее 1 события. Считанные события располагаются в буфере непрерывно.

Функция `handle_events()`  используется для разделения событий в буфере и их последовательной обработки.

Функция `handle_one_event()`  используется для распечатки описания события в поток вывода.

---
## 8_mmap

Программа демонстирует использование
отображения файлов в память.

На первом этапе (функция `make_temp_file()`) 
создается временный файл, в который записывается
массив структур `User` со случайно сгенерированными
полями. Для создания временного
файла используется функция `mkstemp()`, документацию
на которую легко найти в `man`.

На втотом этапе (функция `read_regular`) массив   
из файла считывается с помощью вызова `read()`
по 1 элементу за раз и распечатывается.

На третьем этапе (фунцкия `read_mmap()`) файл 
отображается в память с помощью вызова `mmap()`,
после чего работа с массивом производится так, 
будто он находится в памяти. Размер файла, 
необходимый для отображения, определяется 
вызовом `fstat()` (для читаемости вынесен в 
отдельную функцию `get_file_size()`).


