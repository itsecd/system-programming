# Тема 6. POSIX Threads

## `1_create_thread`

Программа демонстрирует создание потоков, передача аргументов в функцию потока
и получение результата работы потока.

Программа запрашивает у пользователя количество потоков, затем для
каждого потока создает структуру, содержащую данные для обработки
(коэффициенты квадратного уравнения) и создает поток
вызовом функции `pthread_create`.

В качестве функции потока выступает `void* thread_main(void* arg_)`.  
Поскольку номинальный тип аргумента - `void*`, он приводится
к указателю на структуру, после чего производятся необходимые вычисления
и возвращается структура, содержащая найденные корни.

В основной программе результат работы каждого потока считывается через
`pthread_join()` (эта же функция дожидается завершения работы потока).

Стоит отметить, что способ передачи аргументов и возврата результата из потока
зависит от конкретной задачи. В данном примере структура с данными для потока
создается в `main()` и удаляется в потоке, хотя никто не
запрещает удалить ее в основной программе *после* завершения работы потока,
или вовсе не использовать отдельную структуру для возвращаемых значений,
и записать результат в поля структуры-аргумента.

В целом, не возбраняется передавать в поток указатель на локальные переменные,
если можно гарантировать, что время жизни этих переменных превышает время работы потока.

## `2_cancel_thread`

Программа демонстрирует внешнее завершение потока с помощью pthread_cancel().

В программе используются 3 потока:
* главный поток (выполняет `main()`);
* рабочий поток (выполняет `work_thread_fn`)
* поток ожидания (выполняет `wait_thread_fn`)

Рабочий поток сортирует переданный ему массив методом bogosort, 
что занимает значительное время.
Для включения внешнего завершения потока перед началом
сортировки вызывается `pthread_setcanceltype` с параметром
`PTHREAD_CANCEL_ASYNCHRONOUS`, что позволяет завершить поток
в любое время (по умолчанию наличие запроса на завершение проверяется
только при вызове некоторых системных функций).

Поток ожидания ждет пользовательского ввода и, если пользователь
вводит что-либо - посылает запрос на завершение рабочему потоку.

Главный поток создает другие потоки и ждет завершения рабочего потока.
Поскольку результат потока ожидания нас не интересует, после его создания
выполняется `pthread_detach`.

По завершении рабочего потока главный поток выводит
информацию о завершении рабочего потока и состояние массива.

## `3_1_thread_local`

Программа демонстрирует использование ключевого слова `thread_local` из С++.

Глобальные и статические переменные, помеченные как `thread_local`, 
будут иметь в каждом потоке отдельный экземпляр, создаваемый при первом
обращении к ней.

В роли глобальных и `thread_local` выступают структуры NamedObject, которые
выводят сообщения при создании и уничтожении объекта.

Программа запрашивает у пользователя количество потоков, и затем ожидает их
завершения.

Каждый поток увеличивает значение счетчика у глобальной и у `thread_local` переменной
на 1.

При этом в выводе программы будет по 1 сообщению о создании/уничтожении 
глобальной переменной и по N сообщений о создании/уничтожении `thread_local`
переменной. При этом значение счетчика у них также будет отличаться.

## `3_2_tls`

Программа аналогично предыдущей с той разницей, что вместо
ключевого слова `thread_local` явно используются функции  работы TLS.

Ключ TLS создается в начале `main()` вызовом функции `pthread_key_create()`.
При создании ключа с ним ассоциируется функция-деструктор.

Для эмуляции поведения `thread_local`-переменной используется 
функция `get_thread_local()`. 
Функция считывает значение, ассоциированное с ключом TLS.
Если полученный указатель равен NULL, то в динамической памяти
создается объект, его значение записывается в TLS.
Этот же указатель затем возвращается из функции.

## `4_signals`

Программа демонстрирует аспекты работы с сигналами в Pthreads.

Программа создает 4 потока.

В первых 2 потоках разрешен прием сигнала HANDLED_SIGNAL1 (здесь и далее - сигналы заданы макросами).
В первом потоке дополнительно разрешен прием HANDLED_SIGNAL2, во втором потоке - HANDLED_SIGNAL3.
Во вторых 2 потоках все используемые сигналы заблокированы.

Программа сначала трижды посылает сигнал HANDLED_SIGNAL1 всему процессу.
Т.к. целевой поток не указан, этот сигнал может быть обработан как
в потоке 1, так и в потоке 2.

Далее программа трижды посылает сигнал HANDLED_SIGNAL2 всему процессу.
Т.к. данный сигнал может принять только поток 1, он же его и обрабатывает.

Далее программа трижды посылает сигнал HANDLED_SIGNAL1 потоку 1.
Т.к. в этот раз указан конкретный поток, он же и обрабатывает сигнал.

Далее программа трижды посылает сигнал BLOCKED_SIGNAL всему процессу.
Данный сигнал ожидают с помощью `sigwaitinfo()` потоки 3 и 4.
Как следствие, любой из них может забрать сигнал из очереди ожидания.
При этом, если одновременно оба потока попытаются забрать сигнал -
один из них "выиграет" и заберет сигнал, а во втором потоке  
`sigwaitinfo()` провалится с ошибкой EINTR (можете убедиться, раскомментировав строку 49).

Далее программа трижды посылает сигнал BLOCKED_SIGNAL
потоку 3. Поскольку поток указан явно, он и получает сигнал.

Наконец, программа трижды посылает блокируемый сигнал потоку 1,
но никакой реакции от него не поступает.

# 5_nice_and_affinity

Программа демонстрирует пример установки приоритета потока и прикрепления потоков к ядру.

Программа запускает THREAD_COUNT (по умолчанию 16) потоков.
Каждый из потоков увеличивает значение собственного счетчика.
Итоговое значение счетчика на момент завершения будет
пропорционально времени работы потока.

Для обеспечения одновременного старта и остановки работы
используются 2 глобальные переменные `start` и `stop`.

Если ядер достаточно, то даже пониженный приоритет
не скажется на общем времени работы потока.
Для симуляции недостатка ядер все потоки прикрепляются к 1 ядру ЦП
вызовом `pthread_setaffinity_np()`.








