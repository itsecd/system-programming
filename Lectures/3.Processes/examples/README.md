# Тема 3. Процессы

## 1_fork

Программа демонстрирует создание нового процесса вызовом `fork()`. 

В UNIX-подобных системах вызов `fork()` создает (почти полную) копию вызывающего процесса.
При это созданный процесс продолжает выполнение с той же точки. 

В созданном процессе результатом `fork()` будет 0.
В процессе-родителе результатом будет положительное число - PID созданного процесса.

Сравнивая результат `fork()` с 0, можно определить, какой это процесс (родитель или ребенок) 
и выполнить соответствующие действия. В программе - это просто вывод разных сообщений.

## 2_exit_and_atexit

Программа демонстрирует различные способы завершения процесса и их последствия.

Как известно из лекций, программа завершается нормально, если завершена функция `main()` или вызваны `exit()/_exit()`, 
и ненормально - если получен сигнал, диспозиция которого - уничтожение процесса.

При этом, функцией `atexit()` можно зарегистрировать функции, которые будут выполнены при завершении работы процесса,
если закончено выполнение `main()` или вызвана функция `exit()`. 
Обычно такие функции выполняют корректное закрытие занятых ресурсов или иные финальные действия.

Программа регистрирует 2 функции обработчика и затем запрашивает у пользователя метод завершения.
Вывод программы зависит от метода завершения - т.к. от него зависит, выполнятся функции-обработчики, или нет.

## 3_waitpid

Программа демонстрирует ожидание завершения процесса-потомка и анализ причины его завершения
с помощью вызова `waitpid()`.

Программа создает 2 процесса-потомка, первый из которых завершается нормально, 
а второй - ненормально (уничтожается сигналом).

Вызов `waitpid()` в обоих случаях позволяет дождаться завершения процессов и получить информацию о завершении.
Для определения причины завершения и получения дополнительной информации (кода завершения и номера сигала) используются 
соответствующие макросы.

## 4_orphans

Программа демонстрирует явление "усыновления" процессов-сирот.

Процесс-сирота - процесс, "родитель" которого завершился.
Т.к. процесс всегда должен иметь родителя, процесс-сирота "усыновляется" неким другим процессом.

В примере до вызова `fork()` запоминается идентификатор исходного процесса-родителя 
(запомнить до `fork()` важно, т.к. возможна маловероятная ситуация, в которой процесс-родитель завершится до того, как 
дочерний процесс выполнит первый вызов `getppid()`).

Далее дочерний процесс систематически проверяет текущий идентификатор родителя вызовом `getppid()`. 
Если идентификатор родителя отличается от исходного, то процесс осиротел, о чем он уведомляет печальным сообщением.

Процесс-родитель в это время ожидает ввода от пользователя, и по получении завершается.

## 5_exec и 5_scripts.py

Программа демонстрирует запуск другой программы из исполняемого файла вызовом `execve()`.

Программа принимает в качестве аргумента путь к исполняемому файлу.

При запуске программа выводит сообщение, после чего выполняет `execve()` 
и переключается на выполнение другой программы. Этой программе через второй аргумент `execve()` 
передаются оставшиеся аргументы.

Пример запуска программы:

    ./5_exec /bin/echo Hello World

В качестве запускаемого файла `execve()` может быть передан скрипт, с тем ограничением, что файл скрипта
начинается со строки `#! <путь к интерпретатору>`.

Примером такого файла является скрипт `5_sctipt.py`, в первойц строке которого указан путь к интерпретатору Python3.

Пример запуска:

    ./5_exec ../5_script.py 1 2 3 4 5 

## 6_dlopen

Пример демонстрирует динамическую загрузку символов функциями `dlopen()` и `dlsym()`

С помощью `dlopen(NULL, RTLD_NOW)` (строка 12) открывается дескриптор 
глобальной таблицы символов, в которой перечислены символы из всех загруженных исполняемых файлов.
Вызовом функции `dlsym()` (строка 14) из глобальной таблицы извлекается 
указатель на функцию `foo()`,которая затем успешно вызывается.

Вызов `dlopen("libc.so.6", RTLD_NOW)` (строка 20) загружает (если она не была загружена ранее)
и открывает дескриптор таблицы символов библиотеки `libc.so.6`.

Далее вызов `dlsym()`  (строка 26) возвращает адрес функции `puts()`, которая также вызывается.

## 7_limits

Программа демонстрирует ограничение создания дочерних процессов через установку соответствующего предела.

Данный прием может использоваться для защиты от fork-бомб.

Программа сначала распечатывает текущий предел на количество процессов и выполняет `fork()`.

Дочерний процесс понижает жесткий и мягкий пределы до 0 вызовом `setrlimit()` и снова выполняет `fork()`.
Вызов `fork()` проваливается, т.к. мягкий и жесткий пределы равны 0.

При этом процесс не может увеличить предел, т.к. жесткий предел увеличить может только привелигированный процесс.

Если процесс выполнит `execve()` для запуска новой программы, то эта программа не сможет создавать дочерние процессы.
Это может быть полезным для запуска подозрительных программ.

При этом исходный процесс может выполнять `fork()`, т.к. его пределы не изменялись.

## 8_proc

Программа демонстрирует возможности чтения/записи адресного пространства процесса 
через интерфейс псевдо-файловой системы каталога `/proc`.

Файл `/proc/<PID>/mem` представляет собой адресное пространство процесса. 
Чтение-запись файла равны чтению-записи памяти процесса с идентификатором <PID>.

Программа выводит адреса и значения глобальной и локальной переменных, а также команды оболочки для их чтения и модификации, 
после чего ожидает пользовательского ввода.

Если пользователь с помощью команды запишет данные в `/proc/<PID>/mem`, 
то по завершении программа отобразит измененное значение.


## 9_guard_page

Программа демонстрирует использование вызова `mmap()`
для создания guard pages для защиты от переполнения.

Guard page - страница, любая попытка доступа к которой приводит к аппаратному исключению.
Для создания такой страницы в конце некоторой области можно выделить вызовом `mmap()` N+1
страниц с разрешением `PROT_NONE`, а затем для N страниц изменить разрешения на требуемые
вызовом `mprotect()`. Последняя страница диапазона останется с разрешениями `PROT_NONE`,
и любая попытка доступа к ней приведет к получению сигнала `SIGSEGV`.

Программа выделяет 2 буфера, размером 16 байт, считывает в первый буфер пользовательский ввод,
выводит оба буфера и освобождает память.

Если у программы нет аргументов, то используются обычные функции выделения/удаления памяти.
При этом программа намеренно уязвима для переполнения буфера,
чего можно добиться, введя строку длиной более 15.

Если у программы есть аргументы, то попытка переполнения приведет к попытке записи в guard page,
что приведет к аварийному завершению программы.