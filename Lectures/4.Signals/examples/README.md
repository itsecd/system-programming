# Тема 4. Сигналы

## 1_kill

Программа демонстрирует отправку сигналов с помощью системного вызова `kill()` 
и реакцию получателя на сигналы.

Программа создает дочерний процесс, который с некоторым интервалом выводит сообщение в поток вывода.

Затем дочернему процессу посылается сигнал `SIGSTOP`, который останавливает процесс -
сообщения перестают выводиться.

Затем дочернему процессу посылается сигнал `SIGCONT`, который "будит" остановленный процесс - сообщения 
начинают выводиться вновь.

Наконец, дочернему процессу посылается `SIGINT`. Данный сигнал уничтожает процесс, т.к. его диспозиция 
по умолчанию - уничтожение процесса.

## 2_sigaction

Программа демонстрирует изменение диспозиции сигналов вызовом `sigaction()` и синхронизацию по сигналу с помощью `sigsuspend()`.

Программа создает дочерний процесс, который изменяет диспозиции сигналов `SIGABRT` и `SIGQUIT`. 
Сигнал  `SIGABRT` игнорируется, для `SIGQUIT` устанавливается обработчик, 
который запоминает номер пришедшего сигнала.

После этого дочерний процесс входит в цикл ожидания. Вызов `sigsuspen()` приостанавливает работу процесса до тех пор,
пока не придет неигнорируемый сигнал.

Родительский процесс посылает дочернему процессу сигналы `SIGABRT`, `SIGQUIT` и `SIGKILL`.

При этом дочерний процесс реагирует только на `SIGQUIT`, т.к. `SIGABRT` игнорируется, а `SIGKILL` немедленно
уничтожает процесс.

*Примечание: в этом примере обработчики сигналов устанавливаются после `fork()`,
из-за чего приходится вызывать `sleep()`, чтобы сигналы не отправились слишком рано.
В норме вы должны или установить обработчики до `fork()`, или заблокировать
проблемные сигналы до `fork()`, установить обработчики и разблокировать сигналы после `fork()`,
чтобы избежать потенциальных проблем.*

## 3_wrong_handler

Программа демонстрирует эффекты, которые могут наблюдаться при неверном написании обработчика.

*Важно: эта программа собирается в 32-битном варианте*

Программа устанавливает обработчик сигнала `SIGUSR1` и создает новый дочерний процесс.
Дочерний процесс сразу после создания начинает посылать процессу-родителю `SIGUSR1`.
Дочерний процесс завершается, если он осиротеет.

Обработчик сигнала изменяет значение глобальной переменной `value` на -1 всякий раз, когда приходит сигнал.
Основная программа при этом постоянно проверяет значение переменной `value`, после чего сбрасывает 
значение переменной на 0.
Программа завершается только если из `value` было прочитано значение, не равное -1 или 0.

Логика подсказывает, что такая ситуация невозможна, т.к.значение переменной всегда выставляется в 0 или -1 - 
а значит, программа должна работать вечность.

Тем не менее на 32-битных системах чтение и запись 
`long long` неатомарны - разбиваются на 2 32-битных чтения или записи.
Как следствие, если сигнал приходит между 2-мя операциями записи, то в `value` может оказаться значение
`0x00000000FFFFFFFF`  - не -1 и не 0. В этом случае программа завершится.

Для исправления программы достаточно заменить `long long` на `sig_atomic_t` в объявлении `value`.

## 4_sigwaitinfo

Программа демонстрирует 
- установку маски сигналов вызовом `sigprocmask()`;
- использование вызова `sigwaitinfo()` для получения сигнала без его обработки;
- факт "слияния" обычных сигналов при блокировке - если во время блокировки приходят 2 одинаковых сигнала,
то в очереди ожидания останется только один из них.

Программа устанавливает обработчик сигналов `SIGUSR1` и `SIGUSR2` и блокирует оба сигнала вызовом `sigprocmask()`.
После этого программа посылает сама себе сигнал `SIGUSR1`, и дважды посылает себе `SIGUSR2`.

После этого программа извлекает из очереди ожидания сигнал `SIGUSR1`. Обработчик при этом не вызывается.

Далее программа вызовом `sigsuspend()` получает и обрабатывает `SIGUSR2`. Т.к. обработчик срабатывает, 
в поток вывода выводится соответствующая строка.

Далее программа разблокирует все сигналы. Если в этот момент в очереди ожидания был бы `SIGUSR2`, 
то обработчик вызвался бы вновь, однако этого не происходит.

## 5_rtsignal

Программа демонстрирует отличительные особенности сигналов реального времени и особенности работы с ними.

Программа блокирует сигналы `SIGUSR1` и `SIGRTMIN`, после чего устанавливает для них обработчики.
Для установки расширенного обработчика сигнала реального времени используется флаг `SA_SIGINFO` (строка 43).

Далее программа посылает сама себе 2 обычных сигнала `SIGUSR1` и 2 сигнала реального времени `SIGRTMIN`.
Посылка сигналов реального времени осуществляется вызовом `sigqueue()`, при этом вместе с сигналами отправляются 
значения 6311 и 6312.

После отправки сигналов программа снимает блокировку сигналов, 
в результате чего все ожидающие сигналы доставляются процессу и срабатывают их обработчики.

Сигнал `SIGUSR1` доставляется процессу 1 раз, т.к. это обычный сигнал.
Сигнал `SIGRTMIN` доставляется процессу дважды, т.к. сигналы реального времени не "сливаются" вместе. 
Кроме того, вывод обработчиков показывает, что порядок получения сигналов соответствует порядку отправки сигналов.

*Примечание: в обработчиках используется нереентерабельная функция `printf()`, что, вообще говоря, небезопасно.
Однако, если гарантировать, что (1) обработчики не будут прерывать друг друга, и (2) не прервут каккю-либо I/O-функцию
в основной программе, то `printf()` использовать можно. Требование (1) достигается установкой маски обработчика (строки 39 и 40),
а (2) гарантируется автоматически, т.к. `puts()` используется только когда сигналы заблокированы.*

## 6_eintr

Программа демонстрирует прерывание системных вызовов сигналами.

Неигнорируемые сигналы могут прерывать некоторые длительные системные вызовы. 
В этом случае вызов завершается с ошибкой EINTR.

При этом для сигнала может быть указано, что некоторые прерываемые системные вызовы
должны перезапускаться. Для этого используется флаг `SA_RESTART` (строка 49).

Программа устанавливает обработчик сигнала `SIGRTMIN`. 
Флаг `SA_RESTART` указывается, если у программы есть хотя бы 1 аргумент.

Затем программа создает дочерний процесс, который посылает процессу-родителю сигнал `SIGRTMIN` с некоторым интервалом.

Далее процесс-родитель вызывает `sigtimedwait()` для того, чтобы подождать сигнал  `SIGUSR1`.
Когда приходит первый `SIGRTMIN`, системный вызов оказывается прерван, т.к. это не тот сигнал, который ожидался.
При этом, т.к. `sigtimedwait()` - вызов, предназначенный для работы с сигналами, 
`SA_RESTART` не перезапускает системный вызов.

Далее родитель пытается подождать завершения дочернего процессы вызовом `wait()`.
Если при установке обработчика был указан `SA_RESTART`, то после получения сигнала вызов перезапустится
и завершится нормально. В противном случае вызов завершится досрочно с ошибкой.

## 7_hwexceptions

Программа демонстрирует перехват сигнала `SIGFPE`, генерируемого при попытке целочисленного деления на 0.

Некоторые аппаратные исключения представляются ядром в виде сигналов.
В частности, ошибка деления на 0 представляется ядром в виде сигнала SIGFPE. 
В принципе, данный сигнал может быть обработан, и работа программы может быть продолжена,
однако правила обработки подобных сигналов нетривиальны.

## 8_abort

Программа демонстрирует использование функции `abort()` и некоторые особенности ее поведения.

Программа устанавливает обработчик сигнала `SIGABRT`, который внутренне использует функция `abort()`.
После этого программа посылает сама себе `SIGABRT` трижды, чтобы продемонстрировать, что сам по себе
`SIGABRT` не может уничтожить программу. Обработчик трижды выводит сообщение в поток вывода.

После этого программа вызывает `abort()`. В поток вывода выводится еще одно сообщение от обработчика `SIGABRT`,
после чего процесс уничтожается сигналом `SIGABRT`. Данное поведение объясняется тем фактом, что `abort()` 
посылает `SIGABRT`, затем сбрасывает диспозицию `SIGABRT`, и посылает `SIGABRT` еще раз.

## 9_alarm

Программа демонстрирует пример использования `alarm()` для ограничения времени ожидания.


Программа устанавливает обработчик `SIGALRM`, и затем с помощью `alarm()` просит ОС послать сигнал `SIGALRM` спустя 3 секунды.

Затем программа пытается "заснуть" на 10 секунд с помощью вызова `nanosleep()`. 
Сигнал `SIGALRM` прерывает `nanosleep()`, из-за чего программа "недосыпает" 7 секунд.


*Примечание 1: нельзя использовать `sleep()` и `alarm()` вместе.*

*Примечание2: нельзя использовать `alarm()` одновременно в разных потоках, 
т.к. потоки будут сбрасывать таймер и мешать друг другу.*  