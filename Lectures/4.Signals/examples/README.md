# Тема 4. Сигналы

## 1_kill

Программа демонстрирует отправку сигналов с помощью системного вызова `kill()` 
и реакцию получателя на сигналы.

Программа создает дочерний процесс, который с некоторым интервалом выводит сообщение в поток вывода.

Затем дочернему процессу посылается сигнал `SIGSTOP`, который останавливает процесс -
сообщения перестают выводиться.

Затем дочернему процессу посылается сигнал `SIGCONT`, который "будит" остановленный процесс - сообщения 
начинают выводиться вновь.

Наконец, дочернему процессу посылается `SIGINT`. Данный сигнал уничтожает процесс, т.к. его диспозиция 
по умолчанию - уничтожение процесса.

## 2_sigaction

Программа демонстрирует изменение диспозиции сигналов вызовом `sigaction()` и синхронизацию по сигналу с помощью `sigsuspend()`.

Программа создает дочерний процесс, который изменяет диспозиции сигналов `SIGABRT` и `SIGQUIT`. 
Сигнал  `SIGABRT` игнорируется, для `SIGQUIT` устанавливается обработчик, 
который запоминает номер пришедшего сигнала.

После этого дочерний процесс входит в цикл ожидания. Вызов `sigsuspend()` приостанавливает работу процесса до тех пор,
пока не придет неигнорируемый сигнал.

Родительский процесс посылает дочернему процессу сигналы `SIGABRT`, `SIGQUIT` и `SIGKILL`.

При этом дочерний процесс реагирует только на `SIGQUIT`, т.к. `SIGABRT` игнорируется, а `SIGKILL` немедленно
уничтожает процесс.

*Примечание: в этом примере обработчики сигналов устанавливаются после `fork()`,
из-за чего приходится вызывать `sleep()`, чтобы сигналы не отправились слишком рано.
В норме вы должны или установить обработчики до `fork()`, или заблокировать
проблемные сигналы до `fork()`, установить обработчики и разблокировать сигналы после `fork()`,
чтобы избежать потенциальных проблем.*

## 3_error_in_handler

Программа демонстрирует эффекты, которые могут наблюдаться при неверном написании обработчика.

*Важно: эта программа собирается в 32-битном варианте*

Программа устанавливает обработчик сигнала `SIGUSR1` и создает новый дочерний процесс.
Дочерний процесс сразу после создания начинает посылать процессу-родителю `SIGUSR1`.
Дочерний процесс завершается, если он осиротеет.

Обработчик сигнала изменяет значение глобальной переменной `value` на -1 всякий раз, когда приходит сигнал.
Основная программа при этом постоянно проверяет значение переменной `value`, после чего сбрасывает 
значение переменной на 0.
Программа завершается только если из `value` было прочитано значение, не равное -1 или 0.

Логика подсказывает, что такая ситуация невозможна, т.к.значение переменной всегда выставляется в 0 или -1 - 
а значит, программа должна работать вечность.

Тем не менее на 32-битных системах чтение и запись 
`long long` неатомарны - разбиваются на 2 32-битных чтения или записи.
Как следствие, если сигнал приходит между 2-мя операциями записи, то в `value` может оказаться значение
`0x00000000FFFFFFFF`  - не -1 и не 0. В этом случае программа завершится.

Для исправления программы достаточно заменить `long long` на `sig_atomic_t` в объявлении `value`.

## 3_malloc_in_handler

Программа демонстрирует эффекты, которые могут 
наблюдаться при неверном написании обработчика.

В данном примере в обработчике при каждом вызове 
периодически выделяется/освобождается небольшой
объем памяти с помощью `malloc()/free()`.

То же самое происходит в цикле основной программы.

При запуске процесс устанавливает обработчик сигнала
`SIGUSR1` и создает дочерний процесс, после чего входит
в бесконечный цикл выделения/освобождения памяти.

Дочерний процесс после создания начинает посылать родителю
сигнал `SIGUSR1`, что вызывает срабатывание обработчика.

Если срабатывание обработчика наложится по времени
на выполнение `malloc()/free()`, то произойдет нарушение
структуры кучи, что приведет к завершению программы.

Структура кучи разрушается, поскольку изменения, 
производимые `malloc()/free()` частично затираются
изменениями, внесенными другим `malloc()/free()`, в результате
чего куча оказывается в некотором неопределенном состоянии.

## 4_sigwaitinfo

Программа демонстрирует 
- установку маски сигналов вызовом `sigprocmask()`;
- использование вызова `sigwaitinfo()` для получения сигнала без его обработки;
- факт "слияния" обычных сигналов при блокировке - если во время блокировки приходят 2 одинаковых сигнала,
то в очереди ожидания останется только один из них.

Программа устанавливает обработчик сигналов `SIGUSR1` и `SIGUSR2` и блокирует оба сигнала вызовом `sigprocmask()`.
После этого программа посылает сама себе сигнал `SIGUSR1`, и дважды посылает себе `SIGUSR2`.

После этого программа извлекает из очереди ожидания сигнал `SIGUSR1`. Обработчик при этом не вызывается.

Далее программа вызовом `sigsuspend()` получает и обрабатывает `SIGUSR2`. Т.к. обработчик срабатывает, 
в поток вывода выводится соответствующая строка.

Далее программа разблокирует все сигналы. Если в этот момент в очереди ожидания был бы `SIGUSR2`, 
то обработчик вызвался бы вновь, однако этого не происходит.

## 5_rtsignal

Программа демонстрирует отличительные особенности сигналов реального времени и особенности работы с ними.

Программа блокирует сигналы `SIGUSR1` и `SIGRTMIN`, после чего устанавливает для них обработчики.
Для установки расширенного обработчика сигнала реального времени используется флаг `SA_SIGINFO` (строка 43).

Далее программа посылает сама себе 2 обычных сигнала `SIGUSR1` и 2 сигнала реального времени `SIGRTMIN`.
Посылка сигналов реального времени осуществляется вызовом `sigqueue()`, при этом вместе с сигналами отправляются 
значения 6311 и 6312.

После отправки сигналов программа снимает блокировку сигналов, 
в результате чего все ожидающие сигналы доставляются процессу и срабатывают их обработчики.

Сигнал `SIGUSR1` доставляется процессу 1 раз, т.к. это обычный сигнал.
Сигнал `SIGRTMIN` доставляется процессу дважды, т.к. сигналы реального времени не "сливаются" вместе. 
Кроме того, вывод обработчиков показывает, что порядок получения сигналов соответствует порядку отправки сигналов.

*Примечание: в обработчиках используется нереентерабельная функция `printf()`, что, вообще говоря, небезопасно.
Однако, если гарантировать, что (1) обработчики не будут прерывать друг друга, и (2) не прервут каккю-либо I/O-функцию
в основной программе, то `printf()` использовать можно. Требование (1) достигается установкой маски обработчика (строки 39 и 40),
а (2) гарантируется автоматически, т.к. `puts()` используется только когда сигналы заблокированы.*

## 6_eintr

Программа демонстрирует прерывание системных вызовов сигналами.

Неигнорируемые сигналы могут прерывать некоторые длительные системные вызовы. 
В этом случае вызов завершается с ошибкой EINTR.

При этом для сигнала может быть указано, что некоторые прерываемые системные вызовы
должны перезапускаться. Для этого используется флаг `SA_RESTART` (строка 49).

Программа устанавливает обработчик сигнала `SIGRTMIN`. 
Флаг `SA_RESTART` указывается, если у программы есть хотя бы 1 аргумент.

Затем программа создает дочерний процесс, который посылает процессу-родителю сигнал `SIGRTMIN` с некоторым интервалом.

Далее процесс-родитель вызывает `sigtimedwait()` для того, чтобы подождать сигнал  `SIGUSR1`.
Когда приходит первый `SIGRTMIN`, системный вызов оказывается прерван, т.к. это не тот сигнал, который ожидался.
При этом, т.к. `sigtimedwait()` - вызов, предназначенный для работы с сигналами, он прерывается
вне зависимости от флага `SA_RESTART`.

Далее родитель пытается подождать завершения дочернего процессы вызовом `wait()`.
Если при установке обработчика был указан `SA_RESTART`, то после получения сигнала вызов перезапустится
и завершится нормально. В противном случае вызов завершится досрочно с ошибкой.

## 7_hwexceptions

Программа демонстрирует перехват сигналов `SIGFPE` и `SIGSEGV`, генерируемого при попытке целочисленного деления на 0.

Некоторые аппаратные исключения представляются ядром в виде сигналов.
В частности, ошибка деления на 0 представляется ядром в виде сигнала SIGFPE,
а ошибка доступа к памяти - в виде SIGSEGV.

Информация о сигнале доступна через 2 параметр 
расширенного обработчика:
- поле `info->si_code` содержит причину возникновения сигнала;
- поле `info->si_addr` содержит адрес возникновения ошибки.

Если сигнал был отправлен вызовом `kill()` или `sigqueue()`,
то значение `info->si_code` будет равно `SI_USER` либо `SI_QUEUE`,
в противном случае сигнал был отправлен ядром.

В примере функция `zero_division()` генерирует 2 аппаратных
исключения деления на 0 - вещественное и целочисленное. 
Обработчик SIGFPE выводит информацию о них - тип исключения
и адрес инструкции, вызвавшей исключение.

Функция `null_dereference()` генерирует аппаратное 
исключение #PF (page fault). Поскольку ОС не может
найти страницу памяти, соответсвующую `NULL`, исключение
остается необработанным и превращается ОС в `SIGSEGV`.

Функция `access_violation()` генерирует 
исключение #PF с кодом ошибки, означающим 
нарушение прав доступа к странице. 

В обоих случаях обработчик сигнала `SIGSEGV` 
также выводит информацию об ошибке - адрес доступа,
адрес инструкции и причину. При этом, поскольку
для `SIGSEGV` поле `info->si_addr` содержит
адрес доступа, а не адрес инструкции,
последний приходится считывать из сохраненного
состояния ЦП (`ctx->uc_mcontext.gregs[REG_RIP]`).

При перехвате сигнала от аппаратного исключения
нужно учитывать, что по умолчанию после выполнения
обработчика управление передается в ту же точку,
где выполнение было прервано. Т.к. в этой точке
находится инструкция, вызвавшая исключение, 
ошибка произойдет вновь => возникнет вечный цикл.

Как следствие, управление не должно передаваться
в ту же точку. Обработчики сигналов, устанавливаемые
средами выполнения языков высокого уровня, обычно
вызывают код создания исключения и раскрутки стека.
В рамках данного примера ошибочная инструкция просто
пропускается путем модификации программного счетчика
(регистр RIP) в сохраненном состоянии программы
(функция `fix_rip()`); Чтобы не нужно было точно 
рассчитывать размер пропускаемой инструкции, с помощью
ассемблерной вставки после нее добавляется
16 NOP-инструкций (макрос `NOPS`).

## 8_abort

Программа демонстрирует использование функции `abort()` и некоторые особенности ее поведения.

Программа устанавливает обработчик сигнала `SIGABRT`, который внутренне использует функция `abort()`.
После этого программа посылает сама себе `SIGABRT` трижды, чтобы продемонстрировать, что сам по себе
`SIGABRT` не может уничтожить программу. Обработчик трижды выводит сообщение в поток вывода.

После этого программа вызывает `abort()`. В поток вывода выводится еще одно сообщение от обработчика `SIGABRT`,
после чего процесс уничтожается сигналом `SIGABRT`. Данное поведение объясняется тем фактом, что `abort()` 
посылает `SIGABRT`, затем сбрасывает диспозицию `SIGABRT`, и посылает `SIGABRT` еще раз.

## 9_alarm

Программа демонстрирует пример использования `alarm()` для ограничения времени ожидания.

Программа устанавливает обработчик `SIGALRM`, и затем с помощью `alarm()` просит ОС послать сигнал `SIGALRM` спустя 3 секунды.

Затем программа пытается "заснуть" на 10 секунд с помощью вызова `nanosleep()`. 
Сигнал `SIGALRM` прерывает `nanosleep()`, из-за чего программа "недосыпает" 7 секунд.

*Примечание 1: нельзя использовать `sleep()` и `alarm()` вместе.*

*Примечание2: нельзя использовать `alarm()` одновременно в разных потоках, 
т.к. потоки будут сбрасывать таймер и мешать друг другу.*  